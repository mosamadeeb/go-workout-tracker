// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: exercises.sql

package database

import (
	"context"

	"github.com/lib/pq"
)

const addExerciseCategory = `-- name: AddExerciseCategory :one
INSERT INTO exercise_categories (exercise_id, category_id)
VALUES (
    $1,
    $2
)
RETURNING exercise_id, category_id
`

type AddExerciseCategoryParams struct {
	ExerciseID int32
	CategoryID int32
}

func (q *Queries) AddExerciseCategory(ctx context.Context, arg AddExerciseCategoryParams) (ExerciseCategory, error) {
	row := q.db.QueryRowContext(ctx, addExerciseCategory, arg.ExerciseID, arg.CategoryID)
	var i ExerciseCategory
	err := row.Scan(&i.ExerciseID, &i.CategoryID)
	return i, err
}

const addExerciseMuscleGroup = `-- name: AddExerciseMuscleGroup :one
INSERT INTO exercise_muscle_groups (exercise_id, muscle_group_id)
VALUES (
    $1,
    $2
)
RETURNING exercise_id, muscle_group_id
`

type AddExerciseMuscleGroupParams struct {
	ExerciseID    int32
	MuscleGroupID int32
}

func (q *Queries) AddExerciseMuscleGroup(ctx context.Context, arg AddExerciseMuscleGroupParams) (ExerciseMuscleGroup, error) {
	row := q.db.QueryRowContext(ctx, addExerciseMuscleGroup, arg.ExerciseID, arg.MuscleGroupID)
	var i ExerciseMuscleGroup
	err := row.Scan(&i.ExerciseID, &i.MuscleGroupID)
	return i, err
}

const getExerciseCategories = `-- name: GetExerciseCategories :many
SELECT category_id FROM exercise_categories
WHERE exercise_id = $1
`

func (q *Queries) GetExerciseCategories(ctx context.Context, exerciseID int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getExerciseCategories, exerciseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var category_id int32
		if err := rows.Scan(&category_id); err != nil {
			return nil, err
		}
		items = append(items, category_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseMuscleGroups = `-- name: GetExerciseMuscleGroups :many
SELECT muscle_group_id FROM exercise_muscle_groups
WHERE exercise_id = $1
`

func (q *Queries) GetExerciseMuscleGroups(ctx context.Context, exerciseID int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getExerciseMuscleGroups, exerciseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var muscle_group_id int32
		if err := rows.Scan(&muscle_group_id); err != nil {
			return nil, err
		}
		items = append(items, muscle_group_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercisesByCategories = `-- name: GetExercisesByCategories :many
SELECT e.id, e.name, e.description FROM exercises e
JOIN exercise_categories ON id = exercise_id
WHERE category_id = ANY($1::int[])
`

// Returns exercises that have ALL of the given categories
func (q *Queries) GetExercisesByCategories(ctx context.Context, categoryIds []int32) ([]Exercise, error) {
	rows, err := q.db.QueryContext(ctx, getExercisesByCategories, pq.Array(categoryIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercisesByCategoriesAndMuscleGroups = `-- name: GetExercisesByCategoriesAndMuscleGroups :many
SELECT e.id, e.name, e.description FROM exercises e
JOIN exercise_categories c ON e.id = c.exercise_id
JOIN exercise_muscle_groups mg ON e.id = mg.exercise_id
WHERE c.category_id = ANY($1::int[])
AND mg.muscle_group_id = ANY($2::int[])
`

type GetExercisesByCategoriesAndMuscleGroupsParams struct {
	CategoryIds    []int32
	MuscleGroupIds []int32
}

// Returns exercises that have ALL of the given categories and muscle groups
// If either only categories or muscle groups are needed, use the respective query instead of this one
func (q *Queries) GetExercisesByCategoriesAndMuscleGroups(ctx context.Context, arg GetExercisesByCategoriesAndMuscleGroupsParams) ([]Exercise, error) {
	rows, err := q.db.QueryContext(ctx, getExercisesByCategoriesAndMuscleGroups, pq.Array(arg.CategoryIds), pq.Array(arg.MuscleGroupIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercisesByMuscleGroups = `-- name: GetExercisesByMuscleGroups :many
SELECT e.id, e.name, e.description FROM exercises e
JOIN exercise_muscle_groups ON id = exercise_id
WHERE muscle_group_id = ANY($1::int[])
`

// Returns exercises that have ALL of the given muscle groups
func (q *Queries) GetExercisesByMuscleGroups(ctx context.Context, muscleGroupIds []int32) ([]Exercise, error) {
	rows, err := q.db.QueryContext(ctx, getExercisesByMuscleGroups, pq.Array(muscleGroupIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeExerciseCategory = `-- name: RemoveExerciseCategory :exec
DELETE FROM exercise_categories
WHERE exercise_id = $1 AND category_id = $2
`

type RemoveExerciseCategoryParams struct {
	ExerciseID int32
	CategoryID int32
}

func (q *Queries) RemoveExerciseCategory(ctx context.Context, arg RemoveExerciseCategoryParams) error {
	_, err := q.db.ExecContext(ctx, removeExerciseCategory, arg.ExerciseID, arg.CategoryID)
	return err
}

const removeExerciseMuscleGroup = `-- name: RemoveExerciseMuscleGroup :exec
DELETE FROM exercise_muscle_groups
WHERE exercise_id = $1 AND muscle_group_id = $2
`

type RemoveExerciseMuscleGroupParams struct {
	ExerciseID    int32
	MuscleGroupID int32
}

func (q *Queries) RemoveExerciseMuscleGroup(ctx context.Context, arg RemoveExerciseMuscleGroupParams) error {
	_, err := q.db.ExecContext(ctx, removeExerciseMuscleGroup, arg.ExerciseID, arg.MuscleGroupID)
	return err
}
